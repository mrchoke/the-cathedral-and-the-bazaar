\chapter{ออกเนิ่น ๆ ออกถี่ ๆ }

การออกโปรแกรมแต่เนิ่น  ๆ   และบ่อย  ๆ
เป็นส่วนสำคัญยิ่งของรูปแบบการพัฒนาลินุกซ์ นักพัฒนาส่วนมาก
(รวมทั้งผมด้วย) เคยเชื่อว่า
วิธีนี้เป็นนโยบายที่ไม่เข้าท่าเลยสำหรับโครงการขนาดใหญ่
เพราะรุ่นที่ออกเร็ว มักหมายถึงรุ่นที่อุดมไปด้วยบั๊ก
และคุณไม่ต้องการให้ผู้ใช้ละความอดทนกับโปรแกรมไปเร็วนัก

ความเชื่อนี้ถือเป็นการหนุนเสริมความเคยชินที่จะใช้การพัฒนาแบบสร้างมหาวิหาร
ถ้าจุดประสงค์หลักคือการให้ผู้ใช้พบบั๊กให้น้อยที่สุดแล้วล่ะก็
ทำไมคุณถึงคิดจะเว้นช่วงการออกรุ่นถึงหกเดือน (หรือนานกว่านั้น)
โดยทำงานเป็นบ้าเป็นหลังเพื่อตรวจสอบและแก้ไขบั๊กในระหว่างนั้น แกนของ
Emacs ที่เขียนด้วยภาษาซี ก็พัฒนาด้วยวิธีนี้เอง แต่ในทางตรงข้าม ไลบรารี
Lisp กลับใช้วิธีอื่น เพราะมีคลังของ Lisp อยู่นอกการควบคุมของ FSF
(มูลนิธิซอฟต์แวร์เสรี) และเราสามารถจะไปเอา Lisp รุ่นใหม่  ๆ
และรุ่นที่กำลังพัฒนาอยู่มาใช้ได้ โดยไม่ต้องสนใจว่า Emacs
จะมีรุ่นใหม่ออกมาเมื่อไร \pagenote{มีตัวอย่างของการพัฒนาแบบโอเพนซอร์สในตลาดสด
  ที่ประสบความสำเร็จในยุคก่อนอินเทอร์เน็ตบูม
  และไม่เกี่ยวกับธรรมเนียมของยูนิกซ์และอินเทอร์เน็ตด้วย
  การพัฒนาของโปรแกรมบีบอัดซึ่งมุ่งใช้สำหรับดอส ชื่อ
  \href{http://www.cdrom.com/www/infozip/}{info-Zip} ระหว่างปี 1990--1992
  คือตัวอย่างหนึ่งดังกล่าว อีกตัวอย่างหนึ่งคือระบบกระดานข่าว RBBS
  (สำหรับดอสอีกเหมือนกัน) ซึ่งเริ่มต้นในปี 1983
  และได้สร้างชุมชนที่แข็งแกร่งพอที่จะมีการออกรุ่นสม่ำเสมอมาจนถึงปัจจุบัน
  (กลางปี 1999)
  ถึงแม้เมลและการใช้แฟ้มร่วมกันในอินเทอร์เน็ตจะมีข้อได้เปรียบทางเทคนิคอย่างมากเหนือ
  BBS แล้วก็ตาม ในขณะที่ชุมชนของ info-Zip
  อาศัยเมลในอินเทอร์เน็ตในระดับหนึ่ง แต่วัฒนธรรมของนักพัฒนา RBBS
  สามารถจะใช้ชุมชนออนไลน์ผ่าน RBBS ซึ่งไม่ขึ้นกับโครงสร้างพื้นฐาน TCP/IP
  เลยได้}

ในบรรดาคลังเหล่านี้ แหล่งที่สำคัญที่สุด ก็คือคลัง Lisp
ของมหาวิทยาลัยโอไฮโอสเตต
ซึ่งประมาณว่าคงมีหลักการและความสามารถหลายอย่างเหมือนกับคลังซอฟต์แวร์ลินุกซ์ใหญ่  ๆ
ในปัจจุบัน
แต่มีพวกเราน้อยคนที่จะคิดลงไปลึกซึ้งเกี่ยวกับสิ่งที่เราได้ทำลงไป
หรือเกี่ยวกับการมีอยู่ของคลังดังกล่าว
ว่าเป็นเครื่องบ่งชี้ถึงปัญหาของรูปแบบการพัฒนาแบบมหาวิหารของ FSF ในปี
1992 ผมเคยพยายามผนวกโค้ดจากโอไฮโอหลายชิ้นเข้าไปในไลบรารี Lisp
ที่เป็นทางการของ Emacs แต่ติดปัญหาการเมืองใน FSF และล้มเหลวในที่สุด

แต่หนึ่งปีหลังจากนั้น เมื่อลินุกซ์เริ่มเป็นที่รู้จักในวงกว้าง
ก็เป็นที่ชัดเจนว่ารูปแบบการพัฒนาที่แตกต่างและมีประสิทธิภาพกว่าได้เกิดขึ้นที่นั่น
นโยบายการพัฒนาอย่างเปิดกว้างของไลนัสตรงข้ามกับแบบมหาวิหารอย่างสิ้นเชิง
คลังซอฟต์แวร์ของลินุกซ์ในอินเทอร์เน็ตผุดขึ้นอย่างรวดเร็ว
ผู้จัดจำหน่ายต่าง  ๆ   ก็เริ่มเกิดขึ้นมา
สิ่งเหล่านี้เกิดขึ้นได้เพราะความถี่ของการออกของระบบแกน
ซึ่งบ่อยมากชนิดที่เราไม่เคยได้ยินมาก่อน

\noindent ไลนัส ปฏิบัติกับผู้ใช้ของเขาเหมือนกับผู้ร่วมงาน ด้วยวิธีที่ได้ผลที่สุด:

\begin{fancyquotes}
  7. ออกเนิ่น  ๆ   ออกถี่  ๆ   และฟังเสียงผู้ใช้
\end{fancyquotes}

นวัตกรรมของไลนัสไม่ได้อยู่ที่ความไวในการออกรุ่นใหม่
ซึ่งรวบรวมสิ่งที่ผู้ใช้ตอบกลับมาเป็นจำนวนมาก
(เรื่องแบบนี้เป็นขนบในโลกยูนิกซ์ตั้งนานมาแล้ว)
แต่อยู่ที่การขยายขอบเขตความสามารถนี้ขึ้นไปถึงระดับความเข้มข้นที่พอเหมาะกับความซับซ้อนของสิ่งที่เขาพัฒนา
ในช่วงแรกนั้น (ราวปี 1991)
ไม่ใช่เรื่องแปลกเลยที่เขาจะออกเคอร์เนลใหม่มากกว่าหนึ่งครั้ง{[}\emph{ต่อวัน!}{]}
นวัตกรรมนี้เป็นไปได้เพราะเขาได้สร้างฐานผู้ร่วมพัฒนาขนาดใหญ่
และใช้อินเทอร์เน็ตเพื่อการร่วมมือทำงานมากกว่าใคร  ๆ

แต่ว่ามันเป็นไปได้{[}\emph{อย่างไร?}{]} มันเป็นสิ่งที่ผมจะทำตามได้ไหม?
หรือว่านี่เป็นอัจฉริยภาพเฉพาะตัวของ ไลนัส ทอร์วัลด์ เท่านั้น?

ผมไม่คิดอย่างนั้น ผมยอมรับว่าไลนัสเป็นแฮ็กเกอร์ที่เก่งมาก
มีพวกเราสักกี่คนที่จะสามารถสร้างเคอร์เนลของระบบปฏิบัติการระดับคุณภาพโดยเริ่มจากศูนย์ได้อย่างนี้?
แต่ลินุกซ์ไม่ได้เป็นตัวอย่างของการก้าวกระโดดทางความคิดที่ยิ่งใหญ่อะไรเลย
ไลนัสเองก็ไม่ได้เป็น (หรืออย่างน้อยก็ยังไม่ได้เป็น)
อัจฉริยะในการออกแบบผู้สร้างนวัตกรรมในแบบที่ ริชาร์ด สตอลล์แมน หรือ เจมส์
กอสลิง (ผู้สร้าง NeWS และจาวา) เป็นเลย
แต่ไลนัสเป็นอัจฉริยะในการควบคุมการพัฒนา
เขามีสัมผัสพิเศษในการหลีกเลี่ยงบั๊กและทางตันของการพัฒนา
และฉลาดในการหาเส้นทางที่เปลืองแรงน้อยที่สุดจากจุดหนึ่งไปอีกจุดหนึ่ง
อันที่จริง เค้าโครงทั้งหมดของลินุกซ์ก็แสดงออกถึงคุณสมบัติข้อนี้
และสะท้อนถึงแนวทางการออกแบบชนิดอนุรักษ์นิยมและเรียบง่ายของไลนัสเอง

ดังนั้น ถ้าการออกบ่อย  ๆ
และการใช้อินเทอร์เน็ตให้เป็นประโยชน์อย่างเต็มที่ไม่ใช่เรื่องบังเอิญ
แต่เป็นอัจฉริยภาพเชิงวิศวกรรมของไลนัสที่มองทะลุถึงวิธีที่ง่ายและสั้นที่สุดในการพัฒนาล่ะก็
เขากำลังมุ่งเพิ่มปัจจัยอะไร?
อะไรคือสิ่งที่เขาต้องการสร้างขึ้นจากวิธีการทำงานแบบนี้?

คำถามนี้มีคำตอบในตัวมันเองอยู่แล้ว
ไลนัสได้พยายามกระตุ้นและให้รางวัลแก่กลุ่มแฮ็กเกอร์หรือผู้ใช้ของเขาอย่างสม่ำเสมอ
กระตุ้นโดยการสร้างโอกาสที่จะได้เป็นส่วนหนึ่งของงานสร้างสรรค์อันน่าภาคภูมิใจ
ให้รางวัลด้วยความคืบหน้าในงานของพวกเขาที่เห็นได้อย่างไม่ขาดสาย
(ถึงขนาดออกเป็น {[}\emph{รายวัน}{]})

สิ่งที่ไลนัสมุ่งผลักดันให้เพิ่มขึ้นสูงสุดคือปริมาณคน-ชั่วโมงที่ทุ่มเทลงไปในการตรวจสอบบั๊กและการพัฒนา
แม้จะเสี่ยงต่อการเกิดปัญหาด้านเสถียรภาพของโค้ด
และจำนวนผู้ใช้ซึ่งอาจลดลงเมื่อเกิดบั๊กร้ายแรงที่แก้ลำบาก
ไลนัสได้แสดงตัวราวกับว่า เขาเองเชื่อในสิ่งต่อไปนี้:

\begin{fancyquotes}
  8. ถ้ามีผู้ทดสอบและผู้พัฒนามากพอ
  ปัญหาแทบทุกอย่างจะได้รับการรายงานโดยเร็ว
  และใครสักคนจะมองเห็นวิธีแก้ปัญหาได้อย่างปรุโปร่ง
\end{fancyquotes}

หรือพูดง่าย  ๆ   คือ ``ขอให้มีสายตาเฝ้ามองมากพอ
บั๊กทั้งหมดก็เป็นเรื่องง่าย'' (Given enough eyeballs, all bugs are
shallow) ผมขอตั้งคำพูดนี้เป็น ``กฎของไลนัส''

เดิมทีนั้น ผมเขียนกฎนี้ไว้ว่า ปัญหาทุกปัญหา ``จะมีใครบางคนมองออก''
ไลนัสได้ค้านว่า ผู้ที่เข้าใจและสามารถแก้ไขปัญหาได้
ไม่จำเป็นต้องเป็นและมักไม่ใช่คนที่รายงานปัญหาเป็นคนแรก
``มีใครคนหนึ่งเจอปัญหา'' เขากล่าว ``เดี๋ยวก็มี {[}\emph{ใครอีกคน}{]}
ที่เข้าใจตัวปัญหา และผมจะบอกไว้เลยว่า การค้นพบปัญหานั้นท้าทายมากกว่า''
การแก้ข้อความตรงนี้ถือว่าสำคัญ
ซึ่งเราจะเห็นว่ามันสำคัญอย่างไรในหัวข้อถัดไป
เมื่อเราพิจารณาวิธีการแก้บั๊กอย่างละเอียดยิ่งขึ้น แต่สิ่งที่สำคัญคือ
ทั้งสองขั้นตอนของกระบวนการ (การค้นพบและแก้ไขปัญหา)
มีแนวโน้มที่จะเกิดขึ้นอย่างรวดเร็ว

ผมคิดว่า ความแตกต่างโดยพื้นฐานของการพัฒนาแบบมหาวิหารและแบบตลาดสด
ก็อยู่ที่กฎของไลนัสนี่แหละ ในมุมมองของนักพัฒนาแบบสร้างมหาวิหาร
บั๊กและปัญหาในการพัฒนานั้นยาก มีเงื่อนงำ ลึกลับซับซ้อน
ต้องใช้เวลานานนับเดือนในการตรวจสอบโดยการทุ่มเทแรงงานของคนไม่กี่คน
เพื่อจะสร้างความมั่นใจว่าได้กำจัดบั๊กไปหมดแล้ว ผลคือ
ระยะเวลาการออกรุ่นที่ยาวนาน และความผิดหวังที่เลี่ยงไม่ได้
เมื่อโปรแกรมรุ่นใหม่ที่รอคอยมาแสนนานทำงานไม่สมบูรณ์

ในทางกลับกัน ในมุมมองแบบตลาดสด คุณจะถือว่าบั๊กเป็นเรื่องง่าย  ๆ
หรืออย่างน้อยก็จะกลายเป็นเรื่องง่าย  ๆ   อย่างรวดเร็ว
เมื่อเจอกับสายตาของนักพัฒนาผู้กระตือรือร้นนับพันที่ช่วยกันลงไม้ลงมือกับโปรแกรมแต่ละรุ่นที่ออกมา
ดังนั้นคุณจึงออกโปรแกรมให้ถี่เข้าไว้ เพื่อที่บั๊กจะถูกกำจัดมากขึ้น
และผลข้างเคียงที่ดีก็คือ คุณจะลดโอกาสเสียหายถ้ามีปัญหาหลุดออกไปจริง  ๆ

เท่านั้นแหละ เพียงพอแล้ว ถ้า ``กฎของไลนัส'' ผิดล่ะก็
ระบบใดก็ตามที่มีความซับซ้อนมากขนาดเคอร์เนลลินุกซ์
และถูกแฮ็กโดยคนจำนวนมากพอ  ๆ   กัน ก็ควรจะล้ม ณ
จุดใดจุดหนึ่งเพราะการประสานงานที่ไม่ดี และเพราะบั๊ก ``ลึกลับ''
ที่ตรวจไม่พบ ในทางกลับกัน ถ้ากฎของไลนัสถูกต้อง
นี่ก็เพียงพอที่จะอธิบายได้ ว่าทำไมลินุกซ์จึงมีบั๊กน้อย
และไม่ล่มเมื่อเปิดทิ้งไว้เป็นเดือน  ๆ   หรือแม้แต่เป็นปี  ๆ

บางทีเรื่องนี้อาจไม่น่าตื่นเต้นเท่าไรนัก
นักสังคมวิทยาค้นพบหลายปีมาแล้วว่า
ค่าเฉลี่ยของความเห็นจากกลุ่มคนจำนวนมากที่เชี่ยวชาญพอ  ๆ   กัน
(หรือไม่รู้เรื่องพอ  ๆ   กัน)
จะมีความน่าเชื่อถือในการทำนายมากกว่าความเห็นของใครสักคนที่ถูกสุ่มมา
พวกเขาเรียกสิ่งนี้ว่า \emph{ปรากฏการณ์เดลไฟ (Delphi Effect)}
ซึ่งปรากฏว่า สิ่งซึ่งไลนัสได้แสดงให้เห็นก็คือ
ปรากฏการณ์นี้ใช้ได้กับการแก้บั๊กในระบบปฏิบัติการด้วย กล่าวคือ
ปรากฏการณ์เดลไฟสามารถจัดการกับความซับซ้อนของการพัฒนา
แม้กับความซับซ้อนขนาดเคอร์เนลของระบบปฏิบัติการ \pagenote{แนวคิดที่ว่า
  ความโปร่งใสและการตรวจทานโดยนักพัฒนาอื่น
  มีประโยชน์ต่อการจัดการความซับซ้อนของการพัฒนาระบบปฏิบัติการ
  ปรากฏว่าไม่ใช่เรื่องใหม่แต่อย่างใด ในปี 1965 ซึ่งเป็นช่วงแรก  ๆ
  ของประวัติศาสตร์ของระบบปฏิบัติการแบบแบ่งเวลาทำงาน (time-sharing) นั้น
  Corbató และ Vyssotsky ซึ่งเป็นผู้ร่วมออกแบบระบบปฏิบัติการมัลทิกซ์
  (Multics) ได้ \href{http://www.multicians.org/fjcc1.html}{เขียน} ไว้ว่า

  \begin{fancyquotes}
    เราคาดหวังว่าจะเปิดเผยระบบมัลทิกซ์ เมื่อมันทำงานได้อย่างมีเสถียรภาพ..
    การเปิดเผยดังกล่าวเป็นสิ่งที่ดี ด้วยเหตุผลสองประการ: ข้อแรก
    ระบบจะถูกสังเกตและวิจารณ์ในสาธารณะ จากการอาสาสมัครของผู้อ่านที่สนใจ
    ข้อสอง ในยุคที่ความซับซ้อนเพิ่มมากขึ้น
    ก็เป็นความจำเป็นสำหรับนักออกแบบระบบในปัจจุบันและในอนาคต
    ที่จะทำให้ระบบปฏิบัติการภายในชัดเจนที่สุดเท่าที่จะเป็นไปได้
    เพื่อจะได้เห็นประเด็นต่าง  ๆ   ของระบบพื้นฐาน
  \end{fancyquotes}}

ความพิเศษอย่างหนึ่งในกรณีของลินุกซ์
ซึ่งช่วยเสริมปรากฏการณ์เดลไฟเข้าไปอีก
คือการที่ผู้ร่วมสมทบงานในแต่ละโครงการได้ผ่านการกลั่นกรองตัวเองมาแล้ว
ผู้เข้าร่วมตั้งแต่แรกคนหนึ่งชี้ว่า งานที่สมทบเข้ามานั้น
ไม่ใช่ว่ามาจากใครก็ได้ แต่มาจากผู้คนที่สนใจมากพอที่จะใช้ซอฟต์แวร์
เรียนรู้วิธีการทำงาน พยายามหาทางแก้ปัญหาที่พบ
และลงมือสร้างแพตช์ที่ใช้การได้ ใครก็ตามที่ผ่านการกลั่นกรองเหล่านี้
ย่อมมีแนวโน้มที่จะมีสิ่งดี  ๆ   มาร่วมสมทบ

กฎของไลนัสสามารถกล่าวได้อีกแบบว่า ``การแก้บั๊กสามารถทำขนานกันได้''
(Debu\-g\-ging is parallelizable)
ถึงแม้การสื่อสารระหว่างผู้แก้บั๊กกับนักพัฒนาที่ทำหน้าที่ประสานงานจะเป็นเรื่องจำเป็น
แต่ในระหว่างผู้แก้บั๊กด้วยกันเองนั้น แทบไม่ต้องประสานงานกันเลย ดังนั้น
การแก้บั๊กจึงไม่เพิ่มความซับซ้อนและค่าโสหุ้ยในการจัดการเป็นอัตรากำลังสองเหมือนการเพิ่มนักพัฒนา

ในทางปฏิบัติ
การสูญเสียประสิทธิภาพตามทฤษฎีจากการทำงานซ้ำซ้อนของผู้แก้บั๊กนั้น
แทบไม่เกิดกับโลกของลินุกซ์เลย ผลอย่างหนึ่งของนโยบาย ``ออกเนิ่น  ๆ   ถี่  ๆ  ''
ก็คือทำให้ความซ้ำซ้อนดังกล่าวลดลงเหลือน้อยที่สุด
เนื่องจากมีการเผยแพร่การแก้ไขต่าง  ๆ
ที่ได้รับกลับมาออกไปสู่ชุมชนอย่างรวดเร็ว \pagenote{จอห์น แฮสเลอร์
ได้เสนอแนะคำอธิบายที่น่าสนใจสำหรับข้อเท็จจริงที่ว่า
การซ้ำซ้อนของแรงงานดูจะไม่กลายเป็นการหน่วงงานพัฒนาโอเพนซอร์ส
เขาได้เสนอสิ่งที่ผมจะตั้งชื่อให้ว่า ``กฎของแฮสเลอร์'' ซึ่งกล่าวว่า
ค่าโสหุ้ยของงานที่ซ้ำซ้อน
มีแนวโน้มจะโตตามขนาดของทีมงานในอัตราที่ต่ำกว่ากำลังสอง กล่าวคือ
ช้ากว่าค่าโสหุ้ยในการวางแผนและบริหารที่จำเป็นสำหรับการกำจัดความซ้ำซ้อนดังกล่าว

คำอ้างนี้ไม่ได้ขัดกับกฎของบรูกส์ อาจจะจริงที่ว่า
ค่าโสหุ้ยของความซับซ้อนทั้งหมด และความเสี่ยงต่อบั๊ก
จะโตในอัตรากำลังสองตามขนาดของทีม แต่ค่าโสหุ้ยจาก
{[}\emph{งานที่ซ้ำซ้อน}{]} จะเป็นกรณีพิเศษที่โตช้ากว่านั้น
ไม่ยากเลยที่จะให้เหตุผลกับเรื่องนี้
เริ่มจากข้อเท็จจริงที่ไร้ข้อกังขาที่ว่า
เป็นการง่ายกว่าที่จะเห็นพ้องในขอบเขตหน้าที่ระหว่างโค้ดของนักพัฒนาต่าง  ๆ
ซึ่งจะช่วยป้องกันการซ้ำซ้อนของงาน
ถ้าเทียบกับการป้องกันผลที่เกี่ยวเนื่องถึงกันอย่างไม่ตั้งใจในส่วนต่าง  ๆ
ของระบบ ซึ่งทำให้เกิดบั๊กต่าง  ๆ

เมื่อใช้กฎของไลนัสและกฎของแฮสเลอร์ร่วมกัน ก็จะได้ว่า
มีขนาดวิกฤติสามขนาดในโครงการซอฟต์แวร์ต่าง  ๆ   กล่าวคือ ในโครงการเล็ก  ๆ
(ที่มีนักพัฒนาหนึ่งถึงสามคน)
ก็ไม่จำเป็นต้องมีโครงสร้างการบริหารอะไรมากไปกว่าการเลือกนักพัฒนาหลัก
และมีช่วงของโครงการขนาดกลางที่โตกว่านั้น
ซึ่งค่าโสหุ้ยในการบริหารตามปกติจะต่ำ
ทำให้ข้อดีของการเลี่ยงความซ้ำซ้อนของแรงงาน การติดตามบั๊ก
และการตรวจสอบการหลุดรอดของรายละเอียด สามารถเอาชนะค่าโสหุ้ยได้

แต่ในขนาดที่ใหญ่กว่านั้น การใช้กฎของไลนัสและกฎของแฮสเลอร์ร่วมกัน
จะให้ผลว่า มีช่วงของโครงการขนาดใหญ่
ที่ค่าโสหุ้ยและปัญหาของการบริหารแบบเดิม
จะโตเร็วกว่าค่าโสหุ้ยประมาณการของงานที่ซ้ำซ้อน โดยที่ค่าโสหุ้ยเหล่านี้
ยังไม่รวมความไร้ประสิทธิภาพในการใช้ผลของสายตาที่เฝ้ามองจำนวนมาก
ซึ่งอย่างที่เราเห็น
ว่าสามารถทำงานได้ดีกว่าการบริหารแบบเดิมมากในการตรวจสอบบั๊กและรายละเอียดต่าง  ๆ
ดังนั้น ในกรณีของโครงการขนาดใหญ่ ผลของกฎเหล่านี้เมื่อประกอบกัน
จึงทำให้ลดข้อดีของการบริหารแบบเดิมลงจนเหลือศูนย์}

บรูกส์ (ผู้แต่ง \emph{The Mythical Man-Month}) เคยตั้งข้อสังเกตแบบผ่าน  ๆ
เกี่ยวกับเรื่องนี้ไว้ว่า
``ต้นทุนของการดูแลรักษาโปรแกรมที่มีผู้ใช้แพร่หลาย มักมีค่าประมาณร้อยละ
40 ของต้นทุนที่ใช้ในการพัฒนา
น่าแปลกใจตรงที่จำนวนผู้ใช้มีผลกระทบอย่างมากต่อต้นทุนนี้
{[}\emph{ยิ่งมีผู้ใช้มากก็เจอบั๊กมาก}{]}'' {[}เน้นข้อความเพิ่ม{]}

มีผู้ใช้มากก็เจอบั๊กมาก เพราะเมื่อผู้ใช้เพิ่มขึ้น
โอกาสที่จะทรมานโปรแกรมในรูปแบบต่าง  ๆ   กันก็เพิ่มขึ้น
และจะยิ่งเพิ่มขึ้นอีกเมื่อผู้ใช้เป็นผู้ร่วมพัฒนาด้วย
เพราะแต่ละคนจะมีวิธีตรวจบั๊กด้วยมโนทัศน์และเครื่องมือวิเคราะห์ที่ต่างกันไปคนละเล็กละน้อย
จากแง่มุมที่ต่างกัน ดูเหมือนว่า ``ปรากฏการณ์เดลไฟ''
เกิดขึ้นได้ก็เพราะความหลากหลายของผู้ใช้นี่เอง
และโดยเฉพาะในบริบทของการแก้บั๊ก
ความหลากหลายยังมีแนวโน้มที่จะลดงานที่ซ้ำซ้อนอีกด้วย

ดังนั้น การเพิ่มจำนวนผู้ทดสอบอาจจะไม่ช่วยลดความซับซ้อนของบั๊กยาก  ๆ
ในมุมมองของ{[}\emph{นักพัฒนา}{]}
แต่มันจะช่วยเพิ่มโอกาสที่เครื่องมือของใครสักคนจะเหมาะกับตัวปัญหา
จนทำให้บั๊กดูง่าย{[}\emph{สำหรับคนคนนั้น}{]}

ไลนัสยังมีแผนสำรองอยู่อีก ในกรณีที่เกิดบั๊กร้ายแรง
เลขรุ่นของเคอร์เนลลินุกซ์จะถูกกำหนดในลักษณะที่ผู้ใช้สามารถเลือกได้
ว่าจะใช้รุ่น ``เสถียร'' ล่าสุด หรือจะใช้รุ่นใหม่กว่าที่เสี่ยงต่อบั๊ก
เพื่อจะได้ใช้ความสามารถใหม่  ๆ
แฮ็กเกอร์ลินุกซ์ส่วนมากยังไม่ได้นำยุทธวิธีนี้ไปใช้อย่างเป็นระบบ
แต่ก็ควรจะทำ การมีทางเลือกทำให้ทั้งสองทางดูน่าสนใจขึ้น \pagenote{การแยกรุ่นของลินุกซ์
  ระหว่างรุ่นทดสอบและรุ่นเสถียร
  ยังทำหน้าที่อีกอย่างที่เกี่ยวข้องกับการกีดกันความเสี่ยง (แต่ไม่ใช่)
  การแยกรุ่นจะจัดการกับปัญหาอีกข้อหนึ่ง คือการไม่มีเส้นตายของเส้นตาย
  เมื่อโปรแกรมเมอร์ต้องอยู่กับทั้งรายการคุณสมบัติโปรแกรมที่ไม่เปลี่ยนแปลง
  และกำหนดการที่ตายตัว คุณภาพก็จะตก
  และอาจเกิดความยุ่งเหยิงอย่างใหญ่หลวงได้ ถ้าจะทำให้ได้ทั้งสองอย่าง
  ผมเป็นหนี้ต่อ มาร์โค เอียนซิติ และ อลัน แม็คคอร์แม็ค
  จากโรงเรียนธุรกิจฮาร์วาร์ด ที่ได้แสดงหลักฐานให้ผมเห็นว่า
  การผ่อนผันข้อกำหนดอย่างใดอย่างหนึ่ง จะทำให้กำหนดการสามารถบรรลุได้

  ทางหนึ่งที่ทำได้ คือกำหนดเส้นตายตายตัว
  แต่ให้รายการคุณสมบัติโปรแกรมยืดหยุ่นได้ โดยยอมทิ้งคุณสมบัติบางอย่างได้
  ถ้ายังทำไม่เสร็จตามกำหนด นี่คือนโยบายหลักของแขนงเคอร์เนลที่ "เสถียร"
  อลัน ค็อกซ์ (ผู้ดูแลเคอร์เนลรุ่นเสถียร)
  ออกรุ่นเคอร์เนลเป็นระยะค่อนข้างสม่ำเสมอ
  แต่ไม่รับประกันว่าบั๊กไหนจะแก้เมื่อไร
  หรือความสามารถไหนจะถูกถ่ายกลับมาจากแขนงทดสอบ

  หรืออีกทางหนึ่ง ก็คือกำหนดรายการคุณสมบัติที่ต้องการ
  แล้วออกเมื่อทำเสร็จเท่านั้น นี่คือนโยบายหลักของแขนง "ทดสอบ" ของเคอร์เนล
  เดอ มาร์โค และ ลิสเตอร์ ได้อ้างถึงงานวิจัยที่แสดงให้เห็นว่า
  นโยบายกำหนดการแบบนี้ ("ทำเสร็จแล้วปลุกด้วย") จะไม่ใช่แค่ให้คุณภาพสูงสุด
  แต่โดยเฉลี่ยแล้ว ยังทำให้ออกได้เร็วกว่ากำหนดการที่ "ตามความเป็นจริง"
  หรือ "เคร่งครัด" เสียอีก

  ผมได้กลับมาสงสัย (ในช่วงต้นปี 2000) ว่าในบทความนี้รุ่นก่อน  ๆ
  ผมได้ประเมินความสำคัญของนโยบายต่อต้านเส้นตายที่ว่า "ทำเสร็จแล้วปลุกด้วย"
  ต่อผลิตภาพและคุณภาพของชุมชนโอเพนซอร์สต่ำเกินไปอย่างร้ายแรง
  ประสบการณ์ทั่ว  ๆ   ไปของการออก GNOME 1.0 อย่างรีบเร่งในปี 1999
  ทำให้เราเห็นว่า ความกดดันในการออกรุ่นก่อนที่จะพร้อม
  สามารถสลายข้อดีด้านคุณภาพหลายข้อที่โอเพนซอร์สเคยให้ตามปกติได้

  อาจจะกลายเป็นว่า ความโปร่งใสของกระบวนการ
  เป็นหนึ่งในแรงขับดันสามเรื่องที่สำคัญพอ  ๆ   กันต่อคุณภาพของโอเพนซอร์ส
  อีกสองเรื่องก็คือกำหนดการแบบ "ทำเสร็จแล้วปลุกด้วย"
  และการกลั่นกรองตัวเองของนักพัฒนา}